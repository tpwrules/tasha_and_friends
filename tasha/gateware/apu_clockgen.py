# generate the APU frequency output based on the given parameters.

# THEORY OF OPERATION

# The clock generator runs off a 24.75MHz clock, which is connected to the
# freuqency output. There is a 24 bit counter inside that gets a
# user-configurable value added to it every clock cycle. Every time the counter
# overflows, the generator skips the next clock pulse on the output. This has
# the net effect of lowering the average clock rate to a configurable value
# between 24.75MHz (counter = 0x000000) and 1Hz (counter = 0xFFFFFF).

# Additionally, there is a jitter unit which can selectively add jitter to the
# process. When the counter overflows, the jitter unit delays the clock pulse
# skipping by a random number of cycles generated by an LFSR, with a
# user-controlled maximum. This may improve APU communication consistency by
# ensuring that the generated clock's phase is unpredictable and so eliminating
# any especially favorable or unfavorable alignments in wait loops and the like.

# INPUTS

# The "counter" input controls the counter mentioned above.

# The "jitter" input controls the maximum delay added by the jitter unit. A
# setting of 0 turns off jitter, a setting of 1 delays the pulse skipping by 0
# or 1 cycles, a setting of 2 delays 0-3 cycles, etc., up to 7 which delays
# 0-127 cycles. The "jitter_mode" input controls how the LFSR is advanced: if 0,
# the LFSR is advanced every clock cycle; if 1, it's advanced every time a clock
# pulse is skipped.

# NOTE: if the counter value is high so pulses are frequently skipped (i.e. a
# low frequency is being output), then a high amount of jitter may cause the
# pulse skips to be skipped and so unexpectedly raise the output frequency.

# The "polarity" input controls which clock pulses are skipped. If 1, then the
# high pulses are skipped (010 -> 000), and if 0, the low pulses are skipped
# (101 -> 111).

# The effect (if any) of the above settings (except for "counter") is not
# particularly understood, but they are available for experimentation.

from nmigen import *
from nmigen.asserts import Past
from nmigen.lib.cdc import FFSynchronizer

class APUClockgen(Elaboratable):
    def __init__(self):
        self.i_counter = Signal(24)
        self.i_jitter = Signal(3)
        self.i_jitter_mode = Signal()
        self.i_polarity = Signal()

        # DDR outputs. whether lo or hi is modulated depends on the polarity
        self.o_apu_ddr_clk = Signal() # clock for DDR output
        self.o_apu_ddr_lo = Signal() # signal output when clock is low
        self.o_apu_ddr_hi = Signal() # signal output when clock is high

    def elaborate(self, platform):
        m = Module()

        # the inputs almost certainly come from another frequency domain, so we
        # need to sync them to ours. we might should be concerned that they
        # won't all change at the same time but we read them every clock cycle
        # and we'll get the correct value shortly so does it really matter?
        i_counter = Signal(24)
        i_jitter = Signal(3)
        i_jitter_mode = Signal()
        i_polarity = Signal()

        m.submodules += FFSynchronizer(self.i_counter, i_counter)
        m.submodules += FFSynchronizer(self.i_jitter, i_jitter)
        m.submodules += FFSynchronizer(self.i_jitter_mode, i_jitter_mode)
        m.submodules += FFSynchronizer(self.i_polarity, i_polarity)

        # the accumulator (which gets the counter added to it every cycle) is
        # nominally 24 bits wide, but we add another bit at the top to detect
        # overflow. rather than comparing values to detect wraparound, we can
        # just check if the top bit changed.
        accumulator = Signal(25)
        did_overflow = Signal()
        
        m.d.sync += accumulator.eq(accumulator + i_counter)
        last_top = Signal()
        m.d.sync += last_top.eq(accumulator[-1])
        m.d.comb += did_overflow.eq(last_top != accumulator[-1])

        # we jitter by grabbing a certain number of bits from an LFSR (the exact
        # amount is configurable by the low 3 bits of register 3) then waiting
        # that number of cycles before we actually drop the clock.

        jitter_lfsr = Signal(16, reset=1)
        # if thie jitter mode is 1, we only advance the lfsr every time the
        # accumulator overflows. otherwise, it's advanced every cycle.
        with m.If(did_overflow | ~i_jitter_mode):
            with m.If(jitter_lfsr[0]):
                m.d.sync += jitter_lfsr.eq((jitter_lfsr>>1) ^ 0xb400)
            with m.Else():
                m.d.sync += jitter_lfsr.eq(jitter_lfsr>>1)

        next_delay = Signal(7) # jitter-induced delay from the LFSR
        # sample a number of bits according tot he user's desires
        with m.If(i_jitter == 0):
            m.d.sync += next_delay.eq(0)
        with m.Else():
            m.d.sync += next_delay.eq(jitter_lfsr & ((1<<i_jitter)-1))

        do_drop = Signal()
        jitter_delay = Signal(7)
        with m.If(did_overflow):
            with m.If(next_delay == 0): # no delay; drop the clock next cycle
                m.d.comb += do_drop.eq(1)
            m.d.sync += jitter_delay.eq(next_delay)
        with m.Elif(jitter_delay > 0):
            with m.If(jitter_delay == 1): # delay over; drop clock next cycle
                m.d.comb += do_drop.eq(1)
            m.d.sync += jitter_delay.eq(jitter_delay-1)

        # hook the clock output up
        m.d.comb += self.o_apu_ddr_clk.eq(ClockSignal("sync"))
        # choose which pulse to drop based on the polarity
        with m.If(i_polarity):
            # if it's 1, drop the high pulses
            m.d.sync += [
                self.o_apu_ddr_hi.eq(~do_drop), # H = 1 when not dropping
                self.o_apu_ddr_lo.eq(0), # L = 0 always
            ]
        with m.Else():
            # if it's 0, drop the low pulses
            m.d.sync += [
                self.o_apu_ddr_hi.eq(1), # H = 1 always
                self.o_apu_ddr_lo.eq(do_drop), # L = 0 when not dropping
            ]

        return m
